<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aurora Flow â€” Canvas Glow Animation</title>
  <style>
    html,body{height:100%;background:radial-gradient(1200px 800px at 70% 20%, #101826 0%, #0b0f17 50%, #06080f 100%);margin:0;overflow:hidden}
    canvas{display:block; width:100%; height:100%;}
  </style>
</head>
<body>
  <canvas id="main"></canvas>
<script>
(() => {
  const DPR = Math.min(2.5, window.devicePixelRatio || 1);
  const canvas = document.getElementById('main');
  const ctx = canvas.getContext('2d', { alpha: false });
  let W=0, H=0, running=true;
  let particles=[], targetCount=1800, t=0;
  let mouse={x:0,y:0,dx:0,dy:0,down:false};

  function resize(){
    W = canvas.width = Math.floor(window.innerWidth * DPR);
    H = canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.fillStyle = '#0b0f17';
    ctx.fillRect(0,0,W,H);
  }
  window.addEventListener('resize', resize);
  resize();

  const Simplex = (()=>{
    const grad3 = new Float32Array([1,1,-1,1,1,-1,-1,-1,1,0,-1,0,1,0,-1,0,0,1,0,-1,0,1,0,-1]);
    const p = new Uint8Array(256);
    for(let i=0;i<256;i++) p[i]=i;
    for(let i=255;i>0;i--){ const j=(Math.random()*256)|0; const t=p[i]; p[i]=p[j]; p[j]=t; }
    const perm = new Uint8Array(512);
    for(let i=0;i<512;i++) perm[i]=p[i&255];
    function dot(gx, gy, x, y){ return gx*x + gy*y; }
    function noise2D(xin, yin){
      const F2=0.3660254037844386, G2=0.21132486540518713;
      let n0=0,n1=0,n2=0;
      const s=(xin+yin)*F2; const i=Math.floor(xin+s); const j=Math.floor(yin+s);
      const t=(i+j)*G2; let X0=i-t, Y0=j-t; let x0=xin-X0, y0=yin-Y0;
      let i1, j1; if(x0>y0){ i1=1; j1=0; } else { i1=0; j1=1; }
      const x1=x0 - i1 + G2, y1=y0 - j1 + G2;
      const x2=x0 - 1 + 2*G2, y2=y0 - 1 + 2*G2;
      const ii=i & 255, jj=j & 255;
      const gi0=(perm[ii+perm[jj]] % 12)*2;
      const gi1=(perm[ii+i1+perm[jj+j1]] % 12)*2;
      const gi2=(perm[ii+1+perm[jj+1]] % 12)*2;
      let t0=0.5 - x0*x0 - y0*y0; if(t0>0){ t0*=t0; n0 = t0*t0*dot(grad3[gi0],grad3[gi0+1],x0,y0); }
      let t1=0.5 - x1*x1 - y1*y1; if(t1>0){ t1*=t1; n1 = t1*t1*dot(grad3[gi1],grad3[gi1+1],x1,y1); }
      let t2=0.5 - x2*x2 - y2*y2; if(t2>0){ t2*=t2; n2 = t2*t2*dot(grad3[gi2],grad3[gi2+1],x2,y2); }
      return 70*(n0+n1+n2);
    }
    return { noise2D };
  })();

  function curl(x, y, scale=0.0015){
    const eps = 0.0005;
    const n1 = Simplex.noise2D((x+eps)*scale, y*scale);
    const n2 = Simplex.noise2D((x-eps)*scale, y*scale);
    const n3 = Simplex.noise2D(x*scale, (y+eps)*scale);
    const n4 = Simplex.noise2D(x*scale, (y-eps)*scale);
    const dx = (n1 - n2) / (2*eps);
    const dy = (n3 - n4) / (2*eps);
    return { x: dy, y: -dx };
  }

  function makeParticle(){
    const angle = Math.random()*Math.PI*2;
    const radius = Math.sqrt(Math.random())*Math.min(W,H)*0.5;
    const cx = W*0.5, cy = H*0.5;
    return {x: cx + Math.cos(angle)*radius, y: cy + Math.sin(angle)*radius, vx: 0, vy: 0, hueSeed: Math.random(), speed: 0.8 + Math.random()*1.6};
  }

  function init(count){
    particles.length = 0;
    for(let i=0;i<count;i++) particles.push(makeParticle());
  }
  init(targetCount);

  canvas.addEventListener('pointerdown', e=>{ mouse.down=true; const r=canvas.getBoundingClientRect(); mouse.x=(e.clientX-r.left)*DPR; mouse.y=(e.clientY-r.top)*DPR; });
  window.addEventListener('pointerup', ()=>mouse.down=false);
  window.addEventListener('pointermove', e=>{
    const r=canvas.getBoundingClientRect();
    const nx=(e.clientX-r.left)*DPR, ny=(e.clientY-r.top)*DPR;
    mouse.dx = nx - mouse.x; mouse.dy = ny - mouse.y; mouse.x=nx; mouse.y=ny;
  });

  function step(){
    if(!running){ requestAnimationFrame(step); return; }
    ctx.fillStyle = 'rgba(7,10,18,0.08)';
    ctx.fillRect(0,0,W,H);

    for(let i=0;i<particles.length;i++){
      const p = particles[i];
      const f = curl(p.x, p.y);
      let ax = f.x*0.8, ay = f.y*0.8;
      const mx = p.x - mouse.x, my = p.y - mouse.y;
      const d2 = mx*mx + my*my;
      if(mouse.down && d2< (W*H*0.02)){
        const k = 2000 / (d2+1000); // reduced from 12000 to slow particle push
        ax += -mx*k + mouse.dx*0.05; // reduced velocity influence
        ay += -my*k + mouse.dy*0.05;
      }
      p.vx = (p.vx + ax) * 0.97;
      p.vy = (p.vy + ay) * 0.97;
      p.x += p.vx * p.speed;
      p.y += p.vy * p.speed;

      if(p.x< -20) p.x=W+20; if(p.x>W+20) p.x=-20; if(p.y< -20) p.y=H+20; if(p.y>H+20) p.y=-20;

      ctx.strokeStyle = `hsl(${(p.hueSeed + i*0.0007)*360}, 90%, 60%)`;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(p.x - p.vx*4, p.y - p.vy*4);
      ctx.stroke();
    }

    requestAnimationFrame(step);
  }
  step();
})();
</script>
</body>
</html>
